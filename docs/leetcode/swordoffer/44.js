
// 根据数字序列的n找到对应的数字
// 反过来，也会有根据数字，求对应数字序列的位置。

// 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

// 请写一个函数，求任意第n位对应的数字。
// 示例 1：
// 输入：n = 3
// 输出：3
// 示例 2：

// 输入：n = 11
// 输出：0
//  

// 限制：

// 0 <= n < 2^31

// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 这题主要也是找规律
// 1位数： 1~9 9个数字	9个字符
// 2位数： 10~99	9 * 10个数字 9 * 10 * 2个字符
// 3位数： 100~999	9 * 100个数字	9 * 100 * 3个字符
// 每多一位数，也就是对应个数字*对应位数个字符数量

// 那么，拿到n后，就可以定位它在哪个位数上了。

var findNthDigit = function (n) {
    // 小于10，肯定直接return没问题
    if (n < 10) return n;
    // 位数 默认是1
    let i = 1;
    // 默认是9，因为小于10的情况直接return了，所以会从10开始。
    let num = 9;
    let pre = num;
    // 只要n大于num的情况下，如果n小于num了，说明n就是在pre的后面
    while (n >= num) {
        pre = num;
        // 这个就是求位数的所有字符数量。
        i ++;
        num += 9 * 10 ** (i - 1) * i;
    }
    // 这个就是新的字符的下标位置。
    let strIdx = n - pre;
    // 把新的字符除以对应的位数，就可以找到它是哪个数字的偏移量了
    let t = Math.ceil(strIdx / i) - 1;
    // 目标数字就等于前一位的10 + t。
    let targetNum = (10 ** (i - 1) + t) + '';
    // 找到目标数字后，还要根据当前的 strIdx的值，确定它在这个数字的第几个位置。 已经有位数了，它可以 % 位数，但是下标是从0开始的，所以要减一
    let idx = (strIdx - 1) % i;
    return targetNum[idx];
};
// 用一个实例证明
// 15
// 15 > 9 但是15小于99，
// 所以15 - 9 = 6
// 就是说它是一位数结束后的第6个位置。
// 6/2 - 1 = 2
// 说明它是10 + 2 = 12；
// 6 - 1 = 5
// 5 % 2 = 1；
// 所以最后答案是2； 



// 这里是更好的方法 的--可能会理解起来稍微困难
var findNthDigit = function (n) {
    if (n < 10) return n;
    // 位数
    let i = 1;
    let num = 9;
    while (n >= num) {
        n -= num;
        i++;
        num = 9 * 10 ** (i - 1) * i;
    }
    // 此时n就是i位数里面的第几个字符
    // 然后找到是哪个数字
    let t = Math.ceil(n / i) - 1;
    let targetNum = (10 ** (i - 1) + t) + '';
    let idx = (n - 1) % i;
    return targetNum[idx];
};


// 反过来，通过数字找它的序列下标。
// 规律类似

var findNumber = function(n) {
    if(n < 10) return n;
    // 求出n的位数
    var len = (n + '').length;
    var r = len;

    // 求出它减一位之前的所有字符数量和
    r --;
    let str = 0;
    while(r) {
        str += 9 * 10 ** (r - 1) * r
        r --;
    }
    // 得到数量和后，它自己的数字再减去它上家的10的对应次方再加1，因为10 - 10 = 0，但是实际上10已经是2位数的第一个了，所以要加1.本来应该拿10-9的。
    // 这个数字num就是差的数值。
    let num = n - 10 ** (len - 1) + 1;
    // str + num * len就是这个数字的最后一位的下标，求第一为的话，要 用（num - 1）* len 再加1即可。
    return str + (num - 1) * len + 1;
}