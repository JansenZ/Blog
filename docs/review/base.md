### 计算机基础

1. 所有进程管理的思想都是使得拥有不同资源的不同进程同步，只要资源可以被多个进程同时适用，那么它就可能会发生两个问题`死锁`和`饿死`。
2. 死锁就是进程 A 占用了 file1，还要用 file2，进程 B 占用了 file2，还要用 file1，会形成死锁。
3. redis 的内存回收，类似于 LRU 算法，把高频的留下，把低频的往后。最后用的多了的情况下，低频的就滚蛋了
4. java 中类似于 LRU 这样的链表数据结构叫 linkedhashmap， 继承自 hashMap，多了 before,after 等，形成双向循环链表
5. hashmap 的实现机制

    在 Java1.8 以后，HashMap 在数组、链表的基础上又增加了红黑树的数据结构。在一个数组位置的链表长度大于 8 时数据结构转换为红黑树的结构。
    ![hashmap](https://image-static.segmentfault.com/341/431/3414314190-6046f27ddaebd_fix732)

6. 当两个对象的 HashCode 相同会发生什么？

    因为 hashcode 相同，所以它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用链表存储对象，这个 Entry(包含有键值对的 Map.Entry 对象)会存储在链表中。

7. 为什么 jdk1.8 以前用的是头插法，后面改成尾插法？

    因为以前是数组+链表的结构，没有引入红黑树，通常用户新插的数据使用率很高，所以用头插法效率会很高。但是头插法会造成死循环，两个线程一起操作的话

    而后面引入红黑树后，尾插法效率就不会那么低了，虽然不会死循环，但是会丢数据。

    因为他们都不是线程安全的，如果要安全要用 concurrentHashMap,会在操作的时候，锁那一小部分区域。从而不会出问题。

8. 如何通过 ssh 的形式拉仓库

    通过 ssh key 的形式，相当于我把我这台电脑的身份发给了 github，后续交互的时候就不需要输入密码了。

    1. 检查 sshkey 是否存在 `ls -al ~/.ssh` ,存在的话看里面是否有 `id_rsa.pub`
    2. 如果没有的话生成新的 `ssh-keygen -t rsa -C "your_email@example.com"`
    3. 复制 rsa 到 git 服务器上 `pbcopy < ~/.ssh/id_rsa.pub`

9. 如何判断端口是否被占用？
   查询端口`lsof -i:3000`，杀掉对应的占用 pid `kill -9 xxxx`

10. `browser-sync start --server --files "_._"`

### 思想

1. 什么是囚徒困境

    两个犯人，A,B。

    他们坐牢的情况如下，如果都选择抗拒，全只判一年，如果都选择招供，全判 5 年，如果一个选择招供，一个选择抗拒，抗拒的 10 年，招供的 0 年。

    类比于当前的社会内卷上班等等。

    囚犯无法信任彼此，那么 A 的选择如下，如果选择抗拒，就是 1 + 10 = 11 年。 如果选择招供，就是 5 + 0 = 5 年。虽然抗拒的 1 年很好。但是无法信任别人的情况下，风险也很高，所以最重肯定都是招供，就是都是 5 年。

    就像现在的社会一样，如果大家都抵制 996，可能工资都是 20k. 如果有一个人抵制，另外的拥抱，结果抵制的 10K，拥抱的有 30K。如果都拥抱 996，形成内卷，18K 全是。结果就是大家都拥抱，卷起来。
